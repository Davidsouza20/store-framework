"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const vtex_1 = require("vtex");
const specsState_1 = require("./specsState");
const Tester_1 = require("../../../clients/Tester");
const POLL_INTERVAL = 2000;
class EndToEndCommand {
    constructor(options) {
        this.options = options;
        this.tester = Tester_1.Tester.createClient();
    }
    run() {
        if (this.options.workspace) {
            return this.runWorkspaceTests();
        }
        return this.runAppTests();
    }
    async runAppTests() {
        const manifestEditor = await vtex_1.ManifestEditor.getManifestEditor();
        const cleanAppId = manifestEditor.appLocator;
        const apps = vtex_1.createAppsClient();
        const { data: workspaceAppsList } = await apps.listApps();
        const appItem = workspaceAppsList.find(({ app }) => app.startsWith(cleanAppId));
        if (appItem === undefined) {
            throw new Error(`App "${cleanAppId}" was not found in the current workspace!`);
        }
        const testRequest = this.options.report
            ? null
            : await this.tester.test({
                integration: true,
                monitoring: true,
                authToken: this.options.token ? vtex_1.SessionManager.getSingleton().token : undefined,
            }, appItem.id);
        return this.watch(testRequest);
    }
    workspaceBaseUrl() {
        const { account, workspace } = vtex_1.SessionManager.getSingleton();
        return `https://${workspace}--${account}${vtex_1.clusterIdDomainInfix()}.${vtex_1.publicEndpoint()}`;
    }
    reportUrl(testId) {
        return `${this.workspaceBaseUrl()}/_v/report/${testId}/html`;
    }
    async runWorkspaceTests() {
        const testRequest = this.options.report
            ? null
            : await this.tester.test({
                integration: true,
                monitoring: true,
                authToken: this.options.token ? vtex_1.SessionManager.getSingleton().token : undefined,
            });
        return this.watch(testRequest);
    }
    async watch(testRequest) {
        const testId = testRequest ? testRequest.testId : this.options.report;
        const completedApps = new Set();
        vtex_1.logger.info(chalk_1.default.bold('TestId: ') + testId);
        vtex_1.logger.info('Tests running. You will be notified upon each app completion.');
        const timer = setInterval(async () => {
            const report = await this.tester.report(testId);
            const { completedAppTests, runningAppTests } = specsState_1.parseReport(report);
            for (const test of completedAppTests) {
                if (completedApps.has(test.appId)) {
                    continue;
                }
                completedApps.add(test.appId);
                this.notifyApp(test);
            }
            if (runningAppTests.length > 0) {
                return;
            }
            vtex_1.logger.info(`Tests completed! Find the complete report at ${chalk_1.default.underline(this.reportUrl(testId))}`);
            clearInterval(timer);
        }, POLL_INTERVAL);
    }
    notifyApp(app) {
        const { appId, specs } = app;
        vtex_1.logger.info(`${this.appState(specs)} ${this.appName(appId)}`);
    }
    appState(specs) {
        return specsState_1.passedApp(specs) ? chalk_1.default.green('PASS') : chalk_1.default.red('FAIL');
    }
    appName(appId) {
        const { vendor, name, version } = vtex_1.parseLocator(appId);
        return `${chalk_1.default.blue(vendor)}${chalk_1.default.gray.bold('.')}${name}@${version}`;
    }
}
exports.default = (options) => {
    return new EndToEndCommand(options).run();
};
